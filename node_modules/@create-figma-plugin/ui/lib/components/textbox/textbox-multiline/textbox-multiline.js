import { MIXED_STRING } from "@create-figma-plugin/utilities";
import { h } from "preact";
import { useCallback, useRef, useState } from "preact/hooks";
import { createClassName } from "../../../utilities/create-class-name.js";
import { getCurrentFromRef } from "../../../utilities/get-current-from-ref.js";
import { isKeyCodeCharacterGenerating } from "../private/is-keycode-character-generating.js";
import styles from "./textbox-multiline.css";
const EMPTY_STRING = "";
export function TextboxMultiline({ disabled = false, name, noBorder = false, onInput = function () { }, onValueInput = function () { }, placeholder, propagateEscapeKeyDown = true, revertOnEscapeKeyDown = false, rows = 3, spellCheck = false, validateOnBlur, value, ...rest }) {
    const textAreaElementRef = useRef(null);
    const isRevertOnEscapeKeyDownRef = useRef(false);
    const [originalValue, setOriginalValue] = useState(EMPTY_STRING);
    const setTextAreaElementValue = useCallback(function (value) {
        const textAreaElement = getCurrentFromRef(textAreaElementRef);
        textAreaElement.value = value;
        const inputEvent = document.createEvent("Event");
        inputEvent.initEvent("input", true, true);
        textAreaElement.dispatchEvent(inputEvent);
    }, []);
    const handleBlur = useCallback(function () {
        if (isRevertOnEscapeKeyDownRef.current === true) {
            isRevertOnEscapeKeyDownRef.current = false;
            return;
        }
        if (typeof validateOnBlur !== "undefined") {
            const result = validateOnBlur(value);
            if (typeof result === "string") {
                setTextAreaElementValue(result);
                setOriginalValue(EMPTY_STRING);
                return;
            }
            if (result === false) {
                if (value !== originalValue) {
                    setTextAreaElementValue(originalValue);
                }
                setOriginalValue(EMPTY_STRING);
                return;
            }
        }
        setOriginalValue(EMPTY_STRING);
    }, [originalValue, setTextAreaElementValue, validateOnBlur, value]);
    const handleFocus = useCallback(function (event) {
        setOriginalValue(value);
        event.currentTarget.select();
    }, [value]);
    const handleInput = useCallback(function (event) {
        onValueInput(event.currentTarget.value, name);
        onInput(event);
    }, [name, onInput, onValueInput]);
    const handleKeyDown = useCallback(function (event) {
        if (event.key === "Escape") {
            if (propagateEscapeKeyDown === false) {
                event.stopPropagation();
            }
            if (revertOnEscapeKeyDown === true) {
                isRevertOnEscapeKeyDownRef.current = true;
                setTextAreaElementValue(originalValue);
                setOriginalValue(EMPTY_STRING);
            }
            event.currentTarget.blur();
            return;
        }
        if (value === MIXED_STRING &&
            isKeyCodeCharacterGenerating(event.keyCode) === false) {
            event.preventDefault();
            event.currentTarget.select();
        }
    }, [
        originalValue,
        propagateEscapeKeyDown,
        revertOnEscapeKeyDown,
        setTextAreaElementValue,
        value
    ]);
    const handleMouseUp = useCallback(function (event) {
        if (value === MIXED_STRING) {
            event.preventDefault();
        }
    }, [value]);
    return (h("div", { class: createClassName([
            styles.textboxMultiline,
            noBorder === true ? styles.noBorder : null,
            disabled === true ? styles.disabled : null
        ]) }, h("textarea", { ...rest, ref: textAreaElementRef, class: styles.textarea, disabled: disabled === true, name: name, onBlur: handleBlur, onFocus: handleFocus, onInput: handleInput, onKeyDown: handleKeyDown, onMouseUp: handleMouseUp, placeholder: placeholder, rows: rows, spellcheck: spellCheck, tabIndex: disabled === true ? -1 : 0, value: value === MIXED_STRING ? "Mixed" : value }), h("div", { class: styles.border })));
}
//# sourceMappingURL=textbox-multiline.js.map