import { h } from "preact";
import { useCallback, useRef, useState } from "preact/hooks";
import menuStyles from "../../../css/menu.css";
import { useMouseDownOutside } from "../../../hooks/use-mouse-down-outside.js";
import { createClassName } from "../../../utilities/create-class-name.js";
import { getCurrentFromRef } from "../../../utilities/get-current-from-ref.js";
import { IconMenuCheckmarkChecked16 } from "../../icon/icon-16/icon-menu-checkmark-checked-16.js";
import { computeNextValue } from "../private/compute-next-value.js";
import { isKeyCodeCharacterGenerating } from "../private/is-keycode-character-generating.js";
import textboxStyles from "../textbox/textbox.css";
import textboxAutocompleteStyles from "./textbox-autocomplete.css";
const EMPTY_STRING = "";
const INVALID_ID = null;
const ITEM_ID_DATA_ATTRIBUTE_NAME = "data-textbox-autocomplete-item-id";
const MENU_VERTICAL_MARGIN = 16;
export function TextboxAutocomplete({ disabled = false, filter = false, icon, name, noBorder = false, onInput = function () { }, onValueInput = function () { }, placeholder, propagateEscapeKeyDown = true, revertOnEscapeKeyDown = false, spellCheck = false, strict = false, top = false, value, ...rest }) {
    if (typeof icon === "string" && icon.length !== 1) {
        throw new Error(`String \`icon\` must be a single character: ${icon}`);
    }
    const rootElementRef = useRef(null);
    const inputElementRef = useRef(null);
    const menuElementRef = useRef(null);
    const [isMenuVisible, setIsMenuVisible] = useState(false);
    const [selectedId, setSelectedId] = useState(INVALID_ID);
    const [originalValue, setOriginalValue] = useState(EMPTY_STRING);
    const [editedValue, setEditedValue] = useState(value);
    let options = createOptions(rest.options);
    if (filter === true) {
        options = filterOptions(options, value, editedValue);
    }
    const triggerBlur = useCallback(function () {
        setIsMenuVisible(false);
        setOriginalValue(EMPTY_STRING);
        setEditedValue(EMPTY_STRING);
        setSelectedId(INVALID_ID);
        getCurrentFromRef(inputElementRef).blur();
    }, []);
    const updateScrollPosition = useCallback(function (id) {
        const menuElement = getCurrentFromRef(menuElementRef);
        if (id === INVALID_ID) {
            menuElement.scrollTop = 0;
            return;
        }
        const selectedElement = menuElement.querySelector(`[${ITEM_ID_DATA_ATTRIBUTE_NAME}='${id}']`);
        if (selectedElement === null) {
            throw new Error("Invariant violation");
        }
        const y = selectedElement.getBoundingClientRect().y -
            menuElement.getBoundingClientRect().y;
        if (y < menuElement.scrollTop) {
            menuElement.scrollTop = y;
            return;
        }
        const offsetBottom = y + selectedElement.offsetHeight;
        if (offsetBottom > menuElement.scrollTop + menuElement.offsetHeight) {
            menuElement.scrollTop = offsetBottom - menuElement.offsetHeight;
        }
    }, []);
    const updateEditedValue = useCallback(function (editedValue) {
        const newId = getIdByValue(options, editedValue);
        if (newId === INVALID_ID) {
            setEditedValue(editedValue);
            setSelectedId(INVALID_ID);
            updateScrollPosition(INVALID_ID);
            return;
        }
        setEditedValue(EMPTY_STRING);
        setSelectedId(newId);
        updateScrollPosition(newId);
    }, [options, updateScrollPosition]);
    const handleFocus = useCallback(function (event) {
        setIsMenuVisible(true);
        updateMenuElementMaxHeight(getCurrentFromRef(rootElementRef), getCurrentFromRef(menuElementRef), top);
        setOriginalValue(value);
        updateEditedValue(value);
        const inputElement = event.currentTarget;
        inputElement.focus();
        inputElement.select();
    }, [top, updateEditedValue, value]);
    const handleInput = useCallback(function (event) {
        const newValue = event.currentTarget.value;
        updateEditedValue(newValue);
        onValueInput(newValue, name);
        onInput(event);
    }, [name, onInput, onValueInput, updateEditedValue]);
    const handleKeyDown = useCallback(function (event) {
        const inputElement = event.currentTarget;
        const key = event.key;
        if (key === "ArrowUp" || key === "ArrowDown") {
            event.preventDefault();
            if (options.length === 0) {
                return;
            }
            const newId = key === "ArrowUp"
                ? computePreviousId(options, selectedId)
                : computeNextId(options, selectedId);
            if (newId === INVALID_ID) {
                setSelectedId(INVALID_ID);
                inputElement.value = editedValue;
                onValueInput(editedValue, name);
                onInput(event);
                updateScrollPosition(INVALID_ID);
                return;
            }
            setSelectedId(newId);
            updateScrollPosition(newId);
            const newOptionValue = findOptionValueById(options, newId);
            if (newOptionValue === null) {
                throw new Error("Invariant violation");
            }
            const newValue = newOptionValue.value;
            inputElement.value = newValue;
            onValueInput(newValue, name);
            onInput(event);
            inputElement.select();
            return;
        }
        if (key === "Enter" || key === "Escape" || key === "Tab") {
            event.preventDefault();
            if (propagateEscapeKeyDown === false) {
                event.stopPropagation();
            }
            if (key === "Escape" && revertOnEscapeKeyDown === true) {
                inputElement.value = originalValue;
                const inputEvent = document.createEvent("Event");
                inputEvent.initEvent("input", true, true);
                inputElement.dispatchEvent(inputEvent);
            }
            triggerBlur();
            return;
        }
        if (strict === false) {
            return;
        }
        if (event.ctrlKey === true || event.metaKey === true) {
            return;
        }
        if (isKeyCodeCharacterGenerating(event.keyCode) === true) {
            const newValue = computeNextValue(inputElement, event.key);
            if (isValidValue(options, newValue) === false) {
                event.preventDefault();
            }
        }
    }, [
        editedValue,
        name,
        onInput,
        onValueInput,
        options,
        originalValue,
        propagateEscapeKeyDown,
        revertOnEscapeKeyDown,
        selectedId,
        strict,
        triggerBlur,
        updateScrollPosition
    ]);
    const handlePaste = useCallback(function (event) {
        if (event.clipboardData === null) {
            throw new Error("`event.clipboardData` is `null`");
        }
        const newValue = computeNextValue(event.currentTarget, event.clipboardData.getData("Text"));
        if (isValidValue(options, newValue) === false) {
            event.preventDefault();
        }
    }, [options]);
    const handleOptionChange = useCallback(function (event) {
        const newId = event.currentTarget.getAttribute(ITEM_ID_DATA_ATTRIBUTE_NAME);
        setSelectedId(newId);
        const newOptionValue = findOptionValueById(options, newId);
        if (newOptionValue === null) {
            throw new Error("Invariant violation");
        }
        const inputElement = getCurrentFromRef(inputElementRef);
        inputElement.value = newOptionValue.value;
        const inputEvent = document.createEvent("Event");
        inputEvent.initEvent("input", true, true);
        inputElement.dispatchEvent(inputEvent);
        triggerBlur();
    }, [options, triggerBlur]);
    const handleOptionMouseMove = useCallback(function (event) {
        const newId = event.currentTarget.getAttribute(ITEM_ID_DATA_ATTRIBUTE_NAME);
        if (newId !== selectedId) {
            setSelectedId(newId);
        }
    }, [selectedId]);
    const handleMouseDownOutside = useCallback(function () {
        if (isMenuVisible === false) {
            return;
        }
        triggerBlur();
    }, [isMenuVisible, triggerBlur]);
    useMouseDownOutside({
        onMouseDownOutside: handleMouseDownOutside,
        ref: rootElementRef
    });
    return (h("div", { ref: rootElementRef, class: createClassName([
            textboxStyles.textbox,
            noBorder === true ? textboxStyles.noBorder : null,
            typeof icon === "undefined" ? null : textboxStyles.hasIcon,
            disabled === true ? textboxStyles.disabled : null
        ]) }, h("div", { class: textboxStyles.inner }, h("input", { ...rest, ref: inputElementRef, class: textboxStyles.input, disabled: disabled === true, name: name, onFocus: handleFocus, onInput: handleInput, onKeyDown: handleKeyDown, onPaste: handlePaste, placeholder: placeholder, tabIndex: disabled === true ? -1 : 0, type: "text", value: value }), typeof icon === "undefined" ? null : (h("div", { class: textboxStyles.icon }, icon)), h("div", { class: textboxStyles.border }), h("div", { ref: menuElementRef, class: createClassName([
            menuStyles.menu,
            disabled === true || isMenuVisible === false
                ? menuStyles.hidden
                : null,
            top === true
                ? textboxAutocompleteStyles.top
                : textboxAutocompleteStyles.bottom
        ]) }, options.map(function (option, index) {
        if ("separator" in option) {
            return h("hr", { key: index, class: menuStyles.optionSeparator });
        }
        if ("header" in option) {
            return (h("h1", { key: index, class: menuStyles.optionHeader }, option.header));
        }
        return (h("label", { key: index, class: createClassName([
                menuStyles.optionValue,
                option.disabled === true
                    ? menuStyles.optionValueDisabled
                    : null,
                option.disabled !== true && option.id === selectedId
                    ? menuStyles.optionValueSelected
                    : null
            ]) }, h("input", { ...rest, checked: value === option.value, class: menuStyles.input, disabled: option.disabled === true, name: name, onChange: handleOptionChange, onMouseMove: handleOptionMouseMove, spellcheck: spellCheck, tabIndex: -1, type: "radio", value: `${option.value}`, ...{ [ITEM_ID_DATA_ATTRIBUTE_NAME]: option.id } }), option.value === originalValue ? (h("div", { class: menuStyles.checkIcon }, h(IconMenuCheckmarkChecked16, null))) : null, option.value));
    })))));
}
function createOptions(options) {
    return options.map(function (option, index) {
        if ("value" in option) {
            const optionValueWithId = {
                ...option,
                id: `${index}`
            };
            return optionValueWithId;
        }
        return option;
    });
}
function filterOptions(options, value, editedValue) {
    if (value === EMPTY_STRING) {
        return options;
    }
    const id = getIdByValue(options, value);
    if (id === INVALID_ID) {
        return options.filter(function (option) {
            if ("value" in option) {
                return doesStringContainSubstring(option.value, value) === true;
            }
            return false;
        });
    }
    if (editedValue === EMPTY_STRING) {
        return options;
    }
    return options.filter(function (option) {
        if ("value" in option) {
            return doesStringContainSubstring(option.value, editedValue) === true;
        }
        return false;
    });
}
function doesStringContainSubstring(string, substring) {
    return string.toLowerCase().indexOf(substring.toLowerCase()) !== -1;
}
function getIdByValue(options, value) {
    for (const option of options) {
        if ("value" in option) {
            if (option.value === value) {
                return option.id;
            }
        }
    }
    return INVALID_ID;
}
function isValidValue(options, value) {
    if (value === EMPTY_STRING) {
        return true;
    }
    for (const option of options) {
        if ("value" in option) {
            if (option.value.toLowerCase().indexOf(value.toLowerCase()) === 0) {
                return true;
            }
        }
    }
    return false;
}
function findOptionValueById(options, id) {
    for (const option of options) {
        if ("id" in option && option.id === id) {
            return option;
        }
    }
    return null;
}
function getIndexById(options, id) {
    let index = 0;
    for (const option of options) {
        if ("id" in option && option.id === id) {
            return index;
        }
        index += 1;
    }
    return -1;
}
function computePreviousId(options, id) {
    if (id === INVALID_ID) {
        const result = findOptionValueAtOrBeforeIndex(options, options.length - 1);
        return result === null ? null : result.id;
    }
    const index = getIndexById(options, id);
    if (index === -1) {
        throw new Error(`No option with \`id\` ${id}`);
    }
    if (index === 0) {
        return null;
    }
    const result = findOptionValueAtOrBeforeIndex(options, index - 1);
    return result === null ? null : result.id;
}
function computeNextId(options, id) {
    if (id === INVALID_ID) {
        const result = findOptionValueAtOrAfterIndex(options, 0);
        return result === null ? null : result.id;
    }
    const index = getIndexById(options, id);
    if (index === -1) {
        throw new Error(`No option with \`id\` ${id}`);
    }
    if (index === options.length - 1) {
        return null;
    }
    const result = findOptionValueAtOrAfterIndex(options, index + 1);
    return result === null ? null : result.id;
}
function findOptionValueAtOrBeforeIndex(options, index) {
    if (index < 0) {
        throw new Error("`index` < 0");
    }
    if (index > options.length - 1) {
        throw new Error("`index` > `options.length` - 1");
    }
    return findLastOptionValue(options.slice(0, index + 1));
}
function findOptionValueAtOrAfterIndex(options, index) {
    if (index < 0) {
        throw new Error("`index` < 0");
    }
    if (index > options.length - 1) {
        throw new Error("`index` > `options.length` - 1");
    }
    return findFirstOptionValue(options.slice(index));
}
function findFirstOptionValue(options) {
    for (const option of options) {
        if ("id" in option && option.disabled !== true) {
            return option;
        }
    }
    return null;
}
function findLastOptionValue(options) {
    return findFirstOptionValue(options.slice().reverse());
}
function updateMenuElementMaxHeight(rootElement, menuElement, top) {
    const rootElementTop = rootElement.getBoundingClientRect().top;
    const maxHeight = top === true
        ? rootElementTop - MENU_VERTICAL_MARGIN
        : window.innerHeight -
            rootElementTop -
            rootElement.offsetHeight -
            MENU_VERTICAL_MARGIN;
    menuElement.style.maxHeight = `${maxHeight}px`;
}
//# sourceMappingURL=textbox-autocomplete.js.map